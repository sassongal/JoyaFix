PHASE 1: Immediate Security & Stability Hardening1.1. Fix Memory Leak in InputMonitorLocation: InputMonitor.swiftIssue: If the event tap fails to create, the monitor returns early without cleaning up any partially initialized state.Fix:Swiftguard let newEventTap = newEventTap else {
    self.stopMonitoring() // Call centralized cleanup
    Logger.snippet("Failed to create event tap", level: .error)
    return
}
1.2. Toughen API Key ValidationLocation: SettingsManager.swiftIssue: Current validation only checks length and basic whitespace.Fix: Implement Regex-based validation for provider-specific formats:Gemini: ^AIza[0-9A-Za-z_-]{35}$OpenRouter: ^sk-or-v1-[a-z0-9]{64}$ (or equivalent current format).1.3. Secure KeyboardBlocker LifecycleLocation: KeyboardBlocker.swiftIssue: The global instance isn't cleared in deinit, which could cause the C-callback to access a dangling pointer during app transitions.Fix:Swiftdeinit {
    instanceLock.lock()
    if globalKeyboardBlockerInstance === self {
        globalKeyboardBlockerInstance = nil
        globalIsInActiveLockState = false
    }
    instanceLock.unlock()
    removeEventTap()
    hideOverlay()
}
PHASE 2: Performance Optimizations2.1. Replace Polling with FileSystem EventsLocation: ClipboardHistoryManager.swiftIssue: cleanupOrphanedFiles is triggered by a 24-hour timer.Fix: Use DispatchSourceFileSystemObject to monitor the dataDirectory. Only trigger cleanup when the directory is modified, significantly reducing unnecessary background CPU wakeups.2.2. Implement Database PaginationLocation: HistoryDatabaseManager.swiftIssue: loadClipboardHistory() fetches every row into memory at once.Fix: Add LIMIT and OFFSET to SQL queries in HistoryDatabaseManager to load items in batches (e.g., 50 at a time) as the user scrolls the history UI.2.3. Full Image Hash ComparisonLocation: ClipboardHistoryManager.swiftIssue: Image deduplication currently uses only the first 8 characters of a SHA256 hash, which poses a collision risk in large histories.Fix: Compare the full 64-character hash string for deduplication.PHASE 3: Architectural Robustness3.1. Unified Error Handling ServiceIssue: Error handling is currently scattered across Logger.clipboard, Logger.database, and manual NotificationCenter posts.Fix: Create a JoyaFixError enum and a centralized AlertManager to handle logging, toast notifications, and optional crash reporting (via Sentry or similar) in one call.3.2. Structured Concurrency MigrationLocation: ClipboardHistoryManager.swiftIssue: Multiple Task.detached calls are used without a way to cancel them if the app state changes.Fix: Transition to using a TaskGroup or keeping references to Task objects to allow cancellation when stopMonitoring() is called.PHASE 4: Production Deployment & Security4.1. Sandbox & EntitlementsIssue: The app uses high-level permissions like Accessibility and Input Monitoring.Fix:Ensure com.apple.security.temporary-exception.files.home-relative-path.read-write is correctly scoped for ~/Library/Application Support/JoyaFix.Verify Hardened Runtime is enabled for App Store/Notarization requirements.4.2. Automated Notarization PipelineFix: Update build.sh to include xcrun notarytool commands. This ensures that every build intended for users is automatically verified by Appleâ€™s security service, preventing "Unidentified Developer" warnings.4.3. Data Privacy (Sensitive Content)Location: ClipboardItem.swiftIssue: While isSensitive is tracked, the app should explicitly exclude items marked isSensitive from being stored in the full_text or rtf_data_path on disk if the user enables a "Privacy Mode."Summary TimelineWeekFocusObjective1StabilityFix leak in InputMonitor and deinit in KeyboardBlocker.2SecurityImplement API Key Regex and Sandbox entitlement hardening.3PerformanceImplement DB pagination and FileSystem watchers.4DeploymentSet up Notarization and automated DMG signing.